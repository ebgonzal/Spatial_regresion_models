library(readr)
esc_final <- read_csv("Data/esc_final.csv")
View(esc_final)
names(esc_final)
str(esc_final)
summary(esc_final)
vars_resp <- c("I_02", "I_36", "I_710", "I_1114", "I_06", "I_714", "I_314")
# Histograma para cada índice de caries
par(mfrow = c(3, 3))
for (var in vars_resp) {
hist(esc_final[[var]], main = var, xlab = "Índice de caries", col = "skyblue")
}
par(mfrow = c(1, 1))
vars_sociales <- c("pob", "vincNBI", "preciom2", "Dist_CESAC", "Cob_est")
cor(esc_final[, vars_sociales], use = "complete.obs")
library(ggplot2)
# Graficar cada índice contra cada variable social
for (resp in vars_resp) {
for (soc in vars_sociales) {
p <- ggplot(esc_final, aes_string(x = soc, y = resp)) +
geom_point(alpha = 0.6) +
geom_smooth(method = "lm", se = FALSE, color = "red") +
labs(title = paste("Relación entre", resp, "y", soc)) +
theme_minimal()
print(p)
}
}
# Función para ajustar y comparar modelos GLM
ajustar_modelos <- function(resp, data) {
vars <- c("Cob_est", "pob", "vincNBI", "preciom2", "Dist_CESAC")
fórmulas <- lapply(seq_along(vars), function(i) {
as.formula(paste(resp, "~", paste(vars[1:i], collapse = " + ")))
})
modelos <- lapply(fórmulas, function(f) glm(f, data = data, family = gaussian()))
nombres <- paste0("modelo_", seq_along(modelos))
names(modelos) <- nombres
# Comparar con AIC
aics <- sapply(modelos, AIC)
return(list(modelos = modelos, AIC = aics))
}
resultado <- ajustar_modelos("I_02", esc_final)
resultado$AIC  # Menor AIC = mejor modelo
lapply(resultado$modelos, function(mod) formula(mod))
modelo1_lm <- lm(I_02 ~ Cob_est, data = esc_final)
summary(modelo1_lm)
View(modelo1_lm)
pdf("relaciones_indices_variables_sociales.pdf", width = 8, height = 6)
for (resp in vars_resp) {
for (soc in vars_sociales) {
p <- ggplot(esc_final, aes_string(x = soc, y = resp)) +
geom_point(alpha = 0.6) +
geom_smooth(method = "lm", se = FALSE, color = "red") +
labs(title = paste("Relación entre", resp, "y", soc),
x = soc,
y = resp) +
theme_minimal()
print(p)
}
}
dev.off(
resultado <- ajustar_modelos("I_36", esc_final)
resultado$AIC  # Menor AIC = mejor modelo
resultado <- ajustar_modelos("I_36", "esc_final")
resultado <- ajustar_modelos(I_36, esc_final)
resultado <- ajustar_modelos("I_36", esc_final)
resultado$AIC  # Menor AIC = mejor modelo
lapply(resultado$modelos, function(mod) formula(mod))
ajustar_modelos <- function(resp, data) {
vars <- c("Cob_est", "pob", "vincNBI", "preciom2", "Dist_CESAC")
fórmulas <- lapply(seq_along(vars), function(i) {
as.formula(paste(resp, "~", paste(vars[1:i], collapse = " + ")))
})
modelos <- lapply(fórmulas, function(f) glm(f, data = data, family = gaussian()))
nombres <- paste0("modelo_", seq_along(modelos))
names(modelos) <- nombres
# Crear resumen con fórmulas, AIC y BIC
resumen <- data.frame(
Modelo = nombres,
Formula = sapply(modelos, function(mod) deparse(formula(mod))),
AIC = sapply(modelos, AIC),
BIC = sapply(modelos, BIC),
stringsAsFactors = FALSE
)
return(list(modelos = modelos, resumen = resumen))
}
# Ejecutar para I_36
resultado <- ajustar_modelos("I_36", esc_final)
# Ver tabla con modelo + AIC + BIC
print(resultado$resumen)
stepwise_forward <- function(resp, data, criterio = "AIC", p_threshold = 0.05) {
todas_vars <- c("Cob_est", "pob", "vincNBI", "preciom2", "Dist_CESAC")
seleccionadas <- c()
restantes <- todas_vars
mejor_criterio <- Inf
mejor_modelo <- NULL
historial <- data.frame()
while (length(restantes) > 0) {
candidatos <- list()
criterios <- c()
p_vals <- c()
for (var in restantes) {
actual <- c(seleccionadas, var)
f <- as.formula(paste(resp, "~", paste(actual, collapse = " + ")))
mod <- glm(f, data = data, family = gaussian())
candidatos[[var]] <- mod
criterios <- c(criterios, ifelse(criterio == "AIC", AIC(mod), BIC(mod)))
p_vals <- c(p_vals, summary(mod)$coefficients[var, "Pr(>|t|)"])
}
mejor_idx <- which.min(criterios)
mejor_var <- restantes[mejor_idx]
mejor_pval <- p_vals[mejor_idx]
mejor_mod <- candidatos[[mejor_var]]
mejor_valor <- criterios[mejor_idx]
# Chequear si mejora el criterio y p-valor significativo
if (mejor_valor < mejor_criterio && mejor_pval < p_threshold) {
seleccionadas <- c(seleccionadas, mejor_var)
restantes <- setdiff(restantes, mejor_var)
mejor_criterio <- mejor_valor
mejor_modelo <- mejor_mod
historial <- rbind(historial, data.frame(Variable = mejor_var,
AIC = AIC(mejor_mod),
BIC = BIC(mejor_mod),
p_value = mejor_pval))
} else {
break
}
}
return(list(variables = seleccionadas,
modelo = mejor_modelo,
resumen = historial))
}
# Ejecutar ejemplo para I_36
resultado <- stepwise_forward("I_36", esc_final)
# Ver variables seleccionadas
print(resultado$variables)
# Ver tabla con AIC, BIC y p-value por paso
print(resultado$resumen)
# Ver summary del mejor modelo
summary(resultado$modelo)
# Definir función stepwise_forward (asegúrate de tenerla cargada)
stepwise_forward <- function(resp, data, criterio = "AIC", p_threshold = 0.05) {
todas_vars <- c("Cob_est", "pob", "vincNBI", "preciom2", "Dist_CESAC")
seleccionadas <- c()
restantes <- todas_vars
mejor_criterio <- Inf
mejor_modelo <- NULL
historial <- data.frame()
while (length(restantes) > 0) {
candidatos <- list()
criterios <- c()
p_vals <- c()
for (var in restantes) {
actual <- c(seleccionadas, var)
f <- as.formula(paste(resp, "~", paste(actual, collapse = " + ")))
mod <- glm(f, data = data, family = gaussian())
candidatos[[var]] <- mod
criterios <- c(criterios, ifelse(criterio == "AIC", AIC(mod), BIC(mod)))
p_vals <- c(p_vals, summary(mod)$coefficients[var, "Pr(>|t|)"])
}
mejor_idx <- which.min(criterios)
mejor_var <- restantes[mejor_idx]
mejor_pval <- p_vals[mejor_idx]
mejor_mod <- candidatos[[mejor_var]]
mejor_valor <- criterios[mejor_idx]
if (mejor_valor < mejor_criterio && mejor_pval < p_threshold) {
seleccionadas <- c(seleccionadas, mejor_var)
restantes <- setdiff(restantes, mejor_var)
mejor_criterio <- mejor_valor
mejor_modelo <- mejor_mod
historial <- rbind(historial, data.frame(Variable = mejor_var,
AIC = AIC(mejor_mod),
BIC = BIC(mejor_mod),
p_value = mejor_pval))
} else {
break
}
}
return(list(variables = seleccionadas,
modelo = mejor_modelo,
resumen = historial))
}
# Vector con los índices de caries
vars_resp <- c("I_02", "I_36", "I_710", "I_1114", "I_06", "I_714", "I_314")
# Ejecutar stepwise para cada variable de caries
resultados_stepwise <- lapply(vars_resp, function(resp) {
resultado <- stepwise_forward(resp, esc_final)
list(
indice = resp,
seleccionadas = resultado$variables,
resumen = resultado$resumen,
modelo = resultado$modelo
)
})
names(resultados_stepwise) <- vars_resp
# Mostrar resumen de variables seleccionadas por índice
for (res in resultados_stepwise) {
cat("\n==============================\n")
cat("Índice:", res$indice, "\n")
cat("Variables seleccionadas:", paste(res$seleccionadas, collapse = ", "), "\n")
print(res$resumen)
}
# Crear una tabla resumen combinada para todos los modelos
tabla_resumen <- do.call(rbind, lapply(resultados_stepwise, function(res) {
if (nrow(res$resumen) == 0) {
return(data.frame(
Indice = res$indice,
Paso = NA,
Variable = NA,
AIC = NA,
BIC = NA,
p_value = NA
))
} else {
res$resumen$Indice <- res$indice
res$resumen$Paso <- seq_len(nrow(res$resumen))
res$resumen[, c("Indice", "Paso", "Variable", "AIC", "BIC", "p_value")]
}
}))
write.csv(tabla_resumen, "stepwise_resultados.csv", row.names = FALSE)
ggplot(esc_final, aes(x = Cob_est, y = I_36)) +
geom_point() +
geom_smooth(method = "lm", se = FALSE, color = "red") +
theme_minimal()
plot(resultado$modelo, which = 1)  # Residuos vs valores ajustados
plot(resultado$modelo, which = 1)  # Residuos vs valores ajustados
esc_final$Cob_est_z <- scale(esc_final$Cob_est)
summary(esc_final$Cob_est)
hist(esc_final$Cob_est)
library(ggplot2)
# Graficar cada índice contra cada variable social
for (resp in vars_resp) {
for (soc in vars_sociales) {
p <- ggplot(esc_final, aes_string(x = soc, y = resp)) +
geom_point(alpha = 0.6) +
geom_smooth(method = "lm", se = FALSE, color = "red") +
labs(title = paste("Relación entre", resp, "y", soc)) +
theme_minimal()
print(p)
}
}
##############seleccion de mejor modelo GLM##########################
#####################################################################
# Definir función stepwise_forward (asegúrate de tenerla cargada)
stepwise_forward <- function(resp, data, criterio = "AIC", p_threshold = 0.05) {
todas_vars <- c("Cob_est", "pob", "vincNBI", "preciom2", "Dist_CESAC")
seleccionadas <- c()
restantes <- todas_vars
mejor_criterio <- Inf
mejor_modelo <- NULL
historial <- data.frame()
while (length(restantes) > 0) {
candidatos <- list()
criterios <- c()
p_vals <- c()
for (var in restantes) {
actual <- c(seleccionadas, var)
f <- as.formula(paste(resp, "~", paste(actual, collapse = " + ")))
mod <- glm(f, data = data, family = gaussian())
candidatos[[var]] <- mod
criterios <- c(criterios, ifelse(criterio == "AIC", AIC(mod), BIC(mod)))
p_vals <- c(p_vals, summary(mod)$coefficients[var, "Pr(>|t|)"])
}
mejor_idx <- which.min(criterios)
mejor_var <- restantes[mejor_idx]
mejor_pval <- p_vals[mejor_idx]
mejor_mod <- candidatos[[mejor_var]]
mejor_valor <- criterios[mejor_idx]
if (mejor_valor < mejor_criterio && mejor_pval < p_threshold) {
seleccionadas <- c(seleccionadas, mejor_var)
restantes <- setdiff(restantes, mejor_var)
mejor_criterio <- mejor_valor
mejor_modelo <- mejor_mod
historial <- rbind(historial, data.frame(Variable = mejor_var,
AIC = AIC(mejor_mod),
BIC = BIC(mejor_mod),
p_value = mejor_pval))
} else {
break
}
}
return(list(variables = seleccionadas,
modelo = mejor_modelo,
resumen = historial))
}
# Vector con los índices de caries
vars_resp <- c("I_02", "I_36", "I_710", "I_1114", "I_06", "I_714", "I_314")
# Ejecutar stepwise para cada variable de caries
resultados_stepwise <- lapply(vars_resp, function(resp) {
resultado <- stepwise_forward(resp, esc_final)
list(
indice = resp,
seleccionadas = resultado$variables,
resumen = resultado$resumen,
modelo = resultado$modelo
)
})
names(resultados_stepwise) <- vars_resp
# Mostrar resumen de variables seleccionadas por índice
for (res in resultados_stepwise) {
cat("\n==============================\n")
cat("Índice:", res$indice, "\n")
cat("Variables seleccionadas:", paste(res$seleccionadas, collapse = ", "), "\n")
print(res$resumen)
}
# Crear una tabla resumen combinada para todos los modelos
tabla_resumen <- do.call(rbind, lapply(resultados_stepwise, function(res) {
if (nrow(res$resumen) == 0) {
return(data.frame(
Indice = res$indice,
Paso = NA,
Variable = NA,
AIC = NA,
BIC = NA,
p_value = NA
))
} else {
res$resumen$Indice <- res$indice
res$resumen$Paso <- seq_len(nrow(res$resumen))
res$resumen[, c("Indice", "Paso", "Variable", "AIC", "BIC", "p_value")]
}
}))
for (res in resultados_stepwise) {
nombre_modelo <- paste0("modelo_", res$indice)
assign(nombre_modelo, res$modelo, envir = .GlobalEnv)
}
library(sf)
library(spdep)
library(GWmodel)
library(ggplot2)
library(viridis)
library(sf)
library(spdep)
library(GWmodel)
library(ggplot2)
library(viridis)
install.packages("viridis")
# Convertir a sf y luego a Spatial para GWR y Moran
escuelas_sf <- st_as_sf(esc_final, coords = c("POINT_X", "POINT_Y"), crs = 4326)
escuelas_sp <- as(escuelas_sf, "Spatial")
for (indice in indices) {
cat("\n==============================\n")
cat("📌 Índice:", indice, "\n")
# Acceder al modelo por nombre
modelo <- get(paste0("modelo_", indice))
# Obtener residuos
res <- residuals(modelo)
# Crear pesos espaciales
coords <- coordinates(escuelas_sp)
vecinos <- knearneigh(coords, k = 5)
listw <- nb2listw(knn2nb(vecinos))
# Test de Moran
moran <- moran.test(res, listw)
resultados_moran[[indice]] <- moran
cat("Moran’s I:", moran$estimate["Moran I statistic"], "\n")
cat("p-valor:", moran$p.value, "\n")
# Evaluar si hay autocorrelación significativa
if (moran$p.value < 0.05) {
cat("⚠️ Autocorrelación detectada. Corriendo GWR...\n")
# Armar fórmula del modelo
formula_modelo <- formula(modelo)
# Calcular el ancho de banda
bw <- bw.gwr(formula_modelo,
data = escuelas_sp,
approach = "AICc",
kernel = "bisquare",
adaptive = TRUE)
# Ajustar modelo GWR
gwr_model <- gwr.basic(formula_modelo,
data = escuelas_sp,
bw = bw,
kernel = "bisquare",
adaptive = TRUE)
modelos_gwr[[indice]] <- gwr_model
# Exportar coeficientes locales
gwr_sf <- st_as_sf(gwr_model$SDF)
st_write(gwr_sf, paste0("gwr_coef_", indice, ".shp"), delete_layer = TRUE)
# Graficar el primer coeficiente local
primer_var <- names(coef(modelo))[-1][1]
ggplot() +
geom_sf(data = gwr_sf, aes_string(color = primer_var), inherit.aes = FALSE) +
scale_color_viridis_c() +
labs(title = paste("Coeficiente local de", primer_var, "para", indice)) +
theme_minimal()
} else {
cat("✅ Sin autocorrelación espacial. GWR no necesario.\n")
}
}
# Vector de nombres de modelos y sus índices
indices <- c("I_02", "I_36", "I_710", "I_1114", "I_06", "I_714", "I_314")
# Lista para guardar resultados
resultados_moran <- list()
modelos_gwr <- list()
for (indice in indices) {
cat("\n==============================\n")
cat("📌 Índice:", indice, "\n")
# Acceder al modelo por nombre
modelo <- get(paste0("modelo_", indice))
# Obtener residuos
res <- residuals(modelo)
# Crear pesos espaciales
coords <- coordinates(escuelas_sp)
vecinos <- knearneigh(coords, k = 5)
listw <- nb2listw(knn2nb(vecinos))
# Test de Moran
moran <- moran.test(res, listw)
resultados_moran[[indice]] <- moran
cat("Moran’s I:", moran$estimate["Moran I statistic"], "\n")
cat("p-valor:", moran$p.value, "\n")
# Evaluar si hay autocorrelación significativa
if (moran$p.value < 0.05) {
cat("⚠️ Autocorrelación detectada. Corriendo GWR...\n")
# Armar fórmula del modelo
formula_modelo <- formula(modelo)
# Calcular el ancho de banda
bw <- bw.gwr(formula_modelo,
data = escuelas_sp,
approach = "AICc",
kernel = "bisquare",
adaptive = TRUE)
# Ajustar modelo GWR
gwr_model <- gwr.basic(formula_modelo,
data = escuelas_sp,
bw = bw,
kernel = "bisquare",
adaptive = TRUE)
modelos_gwr[[indice]] <- gwr_model
# Exportar coeficientes locales
gwr_sf <- st_as_sf(gwr_model$SDF)
st_write(gwr_sf, paste0("gwr_coef_", indice, ".shp"), delete_layer = TRUE)
# Graficar el primer coeficiente local
primer_var <- names(coef(modelo))[-1][1]
ggplot() +
geom_sf(data = gwr_sf, aes_string(color = primer_var), inherit.aes = FALSE) +
scale_color_viridis_c() +
labs(title = paste("Coeficiente local de", primer_var, "para", indice)) +
theme_minimal()
} else {
cat("✅ Sin autocorrelación espacial. GWR no necesario.\n")
}
}
summary(modelo_I_02)$adj.r.squared
gwr_modelo <- modelos_gwr[["I_02"]]
gwr_modelo$GW.diagnostic$adjR2
gwr_modelo$GW.diagnostic$AICc
summary(modelo_I_36)$adj.r.squared
gwr_modelo <- modelos_gwr[["I_02"]]
gwr_modelo$GW.diagnostic$adjR2
gwr_modelo$GW.diagnostic$AICc
summary(modelo_I_36)$adj.r.squared
gwr_modelo <- modelos_gwr[["I_36"]]
gwr_modelo$GW.diagnostic$adjR2
gwr_modelo$GW.diagnostic$AICc
summary(modelo_I_1114)$adj.r.squared
gwr_modelo <- modelos_gwr[["I_1114"]]
gwr_modelo$GW.diagnostic$adjR2
gwr_modelo$GW.diagnostic$AICc
summary(modelo_I_710)$adj.r.squared
gwr_modelo <- modelos_gwr[["I_710"]]
gwr_modelo$GW.diagnostic$adjR2
gwr_modelo$GW.diagnostic$AICc
summary(modelo_I_06)$adj.r.squared
gwr_modelo <- modelos_gwr[["I_06"]]
gwr_modelo$GW.diagnostic$adjR2
gwr_modelo$GW.diagnostic$AICc
summary(modelo_I_714)$adj.r.squared
gwr_modelo <- modelos_gwr[["I_714"]]
gwr_modelo$GW.diagnostic$adjR2
gwr_modelo$GW.diagnostic$AICc
summary(modelo_I_314)$adj.r.squared
gwr_modelo <- modelos_gwr[["I_314"]]
gwr_modelo$GW.diagnostic$adjR2
gwr_modelo$GW.diagnostic$AICc
